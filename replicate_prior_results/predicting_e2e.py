"""
Replicating work of:

Cameron, C., Chen, R., Hartford, J., & Leyton-Brown, K. (2020). Predicting Propositional Satisfiability via End-to-End
Learning. Proceedings of the AAAI Conference on Artificial Intelligence, 34(04), 3324-3331.
https://doi.org/10.1609/aaai.v34i04.5733

1. Function to convert format is: convert_formula_to_npz_format
2. Functions used to test correctness of converter: read_formula_from_file, check_clause_satisfiability,
   test_formula_is_correctly_encoded
3. Functions used to create dataset: wrapper, create_dataset
4. Functions to split into train-test-validation: _sample_and_remove, create_train_test_valid_txt

"""
import os
import numpy as np
import json
from joblib import Parallel, delayed
import random
import math


MAIN_DIRECTORY = '/Users/amrit/Documents/Data/n_10000_r_4.68/'


def convert_formula_to_npz_format(json_path, npz_path):
    """
    Save formulas generated by us in the .npz format used by the authors.

    :param json_path: Source location of formula saved in JSON format.
    :param npz_path: Destination location of formula converted to npz format.
    :return:
    """
    with open(json_path) as f:
        formula = json.load(f)

    indices, values = [], []
    for idx, clause in enumerate(formula['formula']):
        for literal in clause:
            indices.append([idx, abs(literal) - 1])
            if np.sign(literal) < 0:
                values.append([0, 1])
            else:
                values.append([1, 0])
    y_sat = [1 if i else 0 for i in formula['satisfying_assignment']]
    features = []
    np.savez(npz_path, indices=indices, values=values, y_sat=y_sat, features=features)


def read_formula_from_file(npz_path, m, k=3):
    formula_data = np.load(npz_path, allow_pickle=True)
    unsigned_clauses = formula_data['indices'][:, 1].reshape(m, k) + 1
    sign = formula_data['values'][:, 0]
    sign[sign == 0] = -1
    sign = sign.reshape(m, k)
    formula = np.multiply(unsigned_clauses, sign).tolist()
    return formula, formula_data['y_sat']


def check_clause_satisfiability(assignment, clause):
    """
    :param assignment: Current assignment.
    :param clause: Clause.
    :return: Boolean value that indicates whether the current assignment satisfies the given clause.
    """
    for var in clause:
        var_is_true = (var > 0 and assignment[var - 1]) or (var < 0 and not assignment[abs(var) - 1])
        if var_is_true:
            return True
    return False


def test_formula_is_correctly_encoded(npz_path, m):
    from utilities import CustomError
    formula, assignment = read_formula_from_file(npz_path, m)
    assignment = [i == 1 for i in assignment]
    for clause in formula:
        if not check_clause_satisfiability(assignment, clause):
            raise CustomError(f'Clause {clause} is not satisfied by the given assignment. Please check.')


def wrapper(instance_id, json_folder, npz_folder):
    instance_id = instance_id.split('.')[0]
    json_path = os.path.join(json_folder, f'{instance_id}.json')
    npz_path = os.path.join(npz_folder, f'{instance_id}.json')
    convert_formula_to_npz_format(json_path, npz_path)


def create_dataset(n_jobs=-1, no_of_formulas=3):
    for folder_name in sorted(next(os.walk(MAIN_DIRECTORY))[1]):
        json_folder = f'{MAIN_DIRECTORY}{folder_name}/'
        file_list = sorted([i for i in next(os.walk(json_folder))[2] if 'sat' in i])[:no_of_formulas]

        if folder_name != 'unsat':
            q = int(float(folder_name.replace('q_', '')) * 1000)
        else:
            q = 'unsat'
        npz_folder = f'{MAIN_DIRECTORY}{q}/'
        if not os.path.exists(npz_folder):
            os.makedirs(npz_folder)

        Parallel(n_jobs=n_jobs)(delayed(wrapper)(
            instance_id=f,
            json_folder=json_folder,
            npz_folder=npz_folder
        ) for f in file_list)


def _sample_and_remove(input_list, no_of_samples):
    subsample = random.sample(input_list, no_of_samples)
    input_list = [i for i in input_list if i not in subsample]
    return subsample, input_list


def create_train_test_valid_txt(no_of_formulas=1000, train_size=0.7, test_size=0.2, validation_size=0.1, seed=0):
    # Set seed for replicability.
    random.seed(seed)

    # Create list of all sat and unsat instances.
    instance_idx = [f"{'0' * (6 - len(str(i)))}{i}" for i in range(1, no_of_formulas + 1)]
    sat = [f'sat_{i}.npz' for i in instance_idx]
    unsat = [f'unsat_{i}.npz' for i in instance_idx]

    # Config allows us to perform the same function for each set.
    file_config = [
        {'name': 'train', 'fraction': train_size},
        {'name': 'test', 'fraction': test_size},
        {'name': 'validation', 'fraction': validation_size},
    ]

    # Save {train, text, validation}.txt with a random partition of instances based on input fraction.
    for file_details in file_config:
        no_of_samples = math.floor(file_details['fraction'] * no_of_formulas)
        print(file_details['name'], no_of_samples)
        _sat, sat = _sample_and_remove(sat, no_of_samples)
        _unsat, unsat = _sample_and_remove(unsat, no_of_samples)
        _instances = _sat + _unsat

        with open(f"{file_details['name']}.txt", 'w') as f:
            for instance in _instances:
                f.write(f"{instance}\n")
